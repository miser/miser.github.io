<!DOCTYPE html>
<html class="has-navbar-fixed-top">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
<title>libuv &amp; Node.js EventLoop （一） - Miser 胡言</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">
<meta name="baidu-site-verification" content="CXKjj3fklD">

<meta name="description" content="libuv和Node.js EventLoop关于各个阶段和setTimeout的实现已经做了简单介绍。具体的还是需要看各自版本的代码而定，不能轻易去“相信”网上的介绍，比如最后一个例子就很容易在不同版本出现不同的执行结果。之后，有时间介绍 `nextTick`的回调实现，这个比较复杂。">
 
<meta name="keywords" content="libuv,EventLoop,V8">
   

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">

<link rel="stylesheet" href="/css/style.css">

<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>

      
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-129526171-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-129526171-1');
</script>

  

    <style type="text/css">
      body {
        font-family: Consolas, Mononoki, "Roboto Sans", "Liberation Mono",
          monospace;
        color: #586e75;
        line-height: 1.6;
        background-color: #fdf6e3;
      }
      .gallery-item .caption {
        text-align: center;
      }
      div.adv {
        margin-bottom: 60px;
      }
      ul .img {
        text-align: center;
      }
    </style>
  </head>
  <body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                    
                    胡言
                    
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">Archives</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            
            
            <a class="navbar-item" title="Twitter" href="https://twitter.com/ud_miser">
                
                <i class="fab fa-twitter"></i>
                
            </a>
               
            <a class="navbar-item" title="GitHub" href="https://github.com/miser">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>
 <section class="section">
    <div class="container">
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            libuv &amp; Node.js EventLoop （一）
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2020-02-29T21:39:36.647Z" itemprop="datePublished">Mar 1 2020</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
        </span>
        
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>在网络上查询<a href="https://libuv.org/" target="_blank" rel="noopener">libuv</a>和EventLoop相关信息的时候，经常看到不同的文章所表达的意思差距较多，主要原因有二吧：</p>
<ul>
<li>它们的<code>libuv</code>和<code>V8</code>大版本不同，导致具体的实现略有差异</li>
<li>另外它们的代码错综复杂，又是大多数JavaScript工作者不擅长的C/C++，只是从上而下的看，或许一些细节无法完全理解或是认知的分歧</li>
</ul>
<p>与其受他人影响，不如自己来好好梳理下。</p>
<p><strong>版本</strong></p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// libuv</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UV_VERSION_MAJOR 1</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UV_VERSION_MINOR 33</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UV_VERSION_PATCH 1</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// V8</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> V8_MAJOR_VERSION 7</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> V8_MINOR_VERSION 8</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> V8_BUILD_NUMBER 279</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> V8_PATCH_LEVEL 17</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Node.js</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NODE_MAJOR_VERSION 14</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NODE_MINOR_VERSION 0</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NODE_PATCH_VERSION 0</span></span><br></pre></td></tr></table></figure>
<p>没有列出具体版本号的代码分析都是耍流氓，2010年的代码和2020年的代码可能差距甚远，“上古”分析固然在当时是对的，但是在今日也许是错误的。</p>
<a id="more"></a>
<p><br></p>
<p><br></p>
<h3 id="libuv-amp-EventLoop文档比较"><a href="#libuv-amp-EventLoop文档比较" class="headerlink" title="libuv &amp; EventLoop文档比较"></a>libuv &amp; EventLoop文档比较</h3><p><img src="/images/v8-libuv-timer-event-loop/loop_iteration.png" alt="_images/loop_iteration.png"></p>
<p>上图出自<code>libuv</code>的<a href="http://docs.libuv.org/en/v1.x/design.html#the-i-o-loop" target="_blank" rel="noopener">The I/O loop</a>介绍，具体的信息可以看其文档。</p>
<p><img src="/images/v8-libuv-timer-event-loop/image-20200301145547994.png" alt="image-20200301145547994"></p>
<p>上图出自<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#event-loop-explained" target="_blank" rel="noopener">Event Loop Explained</a>，两者的各个阶段基本是对应的。哪怕是很多其它自行画的图解中，也基本差不多，但唯独<code>pending callbacks</code>阶段，我看到很多文章里面把它标为<code>I/O callbacks</code>，不知道是不是历史原因，但是就从二者的目前文档解释来看是不妥的。</p>
<blockquote>
<p>Pending callbacks are called. All I/O callbacks are called right after polling for I/O, for the most part. There are cases, however, in which calling such a callback is deferred for the next loop iteration. If the previous iteration deferred any I/O callback it will be run at this point. —— libuv</p>
</blockquote>
<p><strong>libuv</strong>里的<code>pending callbacks</code>：大多数的I/O callbacks应该在polling阶段完成，有部分会被延迟到下一个pending callbacks阶段执行。</p>
<p><br></p>
<blockquote>
<p>This phase executes callbacks for some system operations such as types of TCP errors. For example if a TCP socket receives <code>ECONNREFUSED</code> when attempting to connect, some *nix systems want to wait to report the error. This will be queued to execute in the <strong>pending callbacks</strong> phase. —— Node.js</p>
</blockquote>
<p><strong>Node.js</strong>里的<code>pending callbacks</code>：这个阶段会执行系统上因一些错误而引起的callbacks，如TCP错误。</p>
<p>我觉得<code>pending callbacks</code>比较合理，一方面如libuv所说，它是一部分延迟的I/O回调，在Node.js里面指的是一些系统上的错误（这些错误也是I/O引起的）。而大多数的I/O操作其实是在 <code>poll</code>阶段。</p>
<p><br></p>
<p><br></p>
<h2 id="libuv的大致流程代码"><a href="#libuv的大致流程代码" class="headerlink" title="libuv的大致流程代码"></a>libuv的大致流程代码</h2><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uv_run</span><span class="hljs-params">(<span class="hljs-keyword">uv_loop_t</span>* loop, uv_run_mode mode)</span> </span>&#123; <span class="hljs-comment">// 默认 mode 是 UV_RUN_DEFAULT</span></span><br><span class="line">  <span class="hljs-keyword">int</span> timeout;</span><br><span class="line">  <span class="hljs-keyword">int</span> r;</span><br><span class="line">  <span class="hljs-keyword">int</span> ran_pending;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 是否还存在alive的事件</span></span><br><span class="line">  r = uv__loop_alive(loop);</span><br><span class="line">  <span class="hljs-keyword">if</span> (!r)</span><br><span class="line">    uv__update_time(loop); <span class="hljs-comment">// 存在的话更新当前的时间，可以把这个时间理解为libuv里面统一的时间，方便触发定时任务</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">while</span> (r != <span class="hljs-number">0</span> &amp;&amp; loop-&gt;stop_flag == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">    uv__update_time(loop); <span class="hljs-comment">// 和libuv图里的 Update loop time对应</span></span><br><span class="line">    uv__run_timers(loop); <span class="hljs-comment">// 执行 timers 阶段</span></span><br><span class="line">    ran_pending = uv__run_pending(loop); <span class="hljs-comment">// 执行pending 阶段；返回0表示空，1表示有；</span></span><br><span class="line">    uv__run_idle(loop); <span class="hljs-comment">// idle 阶段； Node.js里面不太关心</span></span><br><span class="line">    uv__run_prepare(loop); <span class="hljs-comment">// prepare 阶段； Node.js里面不太关心</span></span><br><span class="line"></span><br><span class="line">    timeout = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化阻塞 poll 阶段的超时时间</span></span><br><span class="line">    <span class="hljs-keyword">if</span> ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)</span><br><span class="line">      timeout = uv_backend_timeout(loop); <span class="hljs-comment">// 算出阻塞 poll 阶段的超时时间</span></span><br><span class="line">    <span class="hljs-comment">// 根据timers里最近的超时时间算出一个差值 diff = loop.time - min.timeout</span></span><br><span class="line">    <span class="hljs-comment">// 如果 diff &gt;= 0 , timeout = 0</span></span><br><span class="line">    <span class="hljs-comment">// 否则 timeout = min(diff, INT_MAX)</span></span><br><span class="line">    </span><br><span class="line">    uv__io_poll(loop, timeout); <span class="hljs-comment">// 执行 poll 阶段</span></span><br><span class="line">    uv__run_check(loop); <span class="hljs-comment">// 执行 check 阶段</span></span><br><span class="line">    uv__run_closing_handles(loop); <span class="hljs-comment">// 执行 close 阶段</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// mode 默认 UV_RUN_DEFAULT 所以不执行下面</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (mode == UV_RUN_ONCE) &#123;</span><br><span class="line">      uv__update_time(loop);</span><br><span class="line">      uv__run_timers(loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 查看是否还有alive事件</span></span><br><span class="line">    r = uv__loop_alive(loop);</span><br><span class="line">    <span class="hljs-keyword">if</span> (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)</span><br><span class="line">      <span class="hljs-keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">/* The if statement lets gcc compile it to a conditional store. Avoids</span></span><br><span class="line"><span class="hljs-comment">   * dirtying a cache line.</span></span><br><span class="line"><span class="hljs-comment">   */</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (loop-&gt;stop_flag != <span class="hljs-number">0</span>)</span><br><span class="line">    loop-&gt;stop_flag = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述<code>uv_run</code>方法同样表达了之前图的循环流程，接下来我们看看各个阶段的具体执行方法。</p>
<p><br></p>
<figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">uv__run_timers</span><span class="hljs-params">(<span class="hljs-keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heap_node</span>* <span class="hljs-title">heap_node</span>;</span> <span class="hljs-comment">// timers 里的都是按照最小堆存放的</span></span><br><span class="line">  <span class="hljs-keyword">uv_timer_t</span>* handle;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">    heap_node = heap_min(timer_heap(loop)); <span class="hljs-comment">// 从堆顶取出一个</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (heap_node == <span class="hljs-literal">NULL</span>) <span class="hljs-comment">// 不存在就退出</span></span><br><span class="line">      <span class="hljs-keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    handle = container_of(heap_node, <span class="hljs-keyword">uv_timer_t</span>, heap_node); </span><br><span class="line">    <span class="hljs-keyword">if</span> (handle-&gt;timeout &gt; loop-&gt;time) <span class="hljs-comment">// 触发时间没达到也退出</span></span><br><span class="line">      <span class="hljs-keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    uv_timer_stop(handle);</span><br><span class="line">    uv_timer_again(handle);</span><br><span class="line">    </span><br><span class="line">    handle-&gt;timer_cb(handle); <span class="hljs-comment">// 执行回调</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>timers里存放的事件都是最小堆的数据结构排列的，不断的取出根节点比较当前的<code>loop-&gt;time</code>就能知道是执行还是退出，<strong>那么这里的<code>handle-&gt;timer_cb</code>是我们平时JavaScript里的setTimeout回调吗？</strong>后续解答</p>
<p><br></p>
<figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uv__run_pending</span><span class="hljs-params">(<span class="hljs-keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  QUEUE* q;</span><br><span class="line">  QUEUE pq;</span><br><span class="line">  <span class="hljs-keyword">uv__io_t</span>* w;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (QUEUE_EMPTY(&amp;loop-&gt;pending_queue))</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">  QUEUE_MOVE(&amp;loop-&gt;pending_queue, &amp;pq);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">while</span> (!QUEUE_EMPTY(&amp;pq)) &#123; <span class="hljs-comment">// 双向链表，为空就跳出</span></span><br><span class="line">    q = QUEUE_HEAD(&amp;pq);</span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    QUEUE_INIT(q);</span><br><span class="line">    w = QUEUE_DATA(q, <span class="hljs-keyword">uv__io_t</span>, pending_queue);</span><br><span class="line">    w-&gt;cb(loop, w, POLLOUT); <span class="hljs-comment">// 执行回调</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>libuv里面事件很多是由双向链表构建而成，等着被一个个执行，双向链表的好处就是插入很容易。</p>
<p><br></p>
<figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UV_LOOP_WATCHER_DEFINE(name, type)                                    \</span></span><br><span class="line">	<span class="hljs-keyword">void</span> uv__run_#<span class="hljs-meta">#name(uv_loop_t* loop) &#123;                                      \</span></span><br><span class="line">    uv_#<span class="hljs-meta">#name##_t* h;                                                         \</span></span><br><span class="line">    QUEUE <span class="hljs-built_in">queue</span>;                                                              \</span><br><span class="line">    QUEUE* q;                                                                 \</span><br><span class="line">    QUEUE_MOVE(&amp;loop-&gt;name##_handles, &amp;<span class="hljs-built_in">queue</span>);                                \</span><br><span class="line">    <span class="hljs-keyword">while</span> (!QUEUE_EMPTY(&amp;<span class="hljs-built_in">queue</span>)) &#123;                                            \</span><br><span class="line">      q = QUEUE_HEAD(&amp;<span class="hljs-built_in">queue</span>);                                                 \</span><br><span class="line">      h = QUEUE_DATA(q, uv_##name##<span class="hljs-keyword">_t</span>, <span class="hljs-built_in">queue</span>);                                \</span><br><span class="line">      QUEUE_REMOVE(q);                                                        \</span><br><span class="line">      QUEUE_INSERT_TAIL(&amp;loop-&gt;name##_handles, q);                            \</span><br><span class="line">      h-&gt;name##_cb(h);                                                        \</span><br><span class="line">    &#125;                                                                         \</span><br><span class="line">  &#125;     </span><br><span class="line"></span><br><span class="line">UV_LOOP_WATCHER_DEFINE(prepare, PREPARE)</span><br><span class="line">UV_LOOP_WATCHER_DEFINE(check, CHECK)</span><br><span class="line">UV_LOOP_WATCHER_DEFINE(idle, IDLE)</span><br></pre></td></tr></table></figure>
<p><code>UV_LOOP_WATCHER_DEFINE</code>宏直接初始化了<code>prepare</code>、<code>check</code>和<code>idle</code>3个阶段，都是双向链表。</p>
<p><br></p>
<figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// uv__io_poll 太长了，不重要的代码已经移除</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">uv__io_poll</span><span class="hljs-params">(<span class="hljs-keyword">uv_loop_t</span>* loop, <span class="hljs-keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// ...</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (loop-&gt;nfds == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 没有需要执行的 直接退出</span></span><br><span class="line">    assert(QUEUE_EMPTY(&amp;loop-&gt;watcher_queue));</span><br><span class="line">    <span class="hljs-keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 将loop-&gt;watcher_queue列队里的待观察的文件描述符绑定到epoll上</span></span><br><span class="line">  <span class="hljs-keyword">while</span> (!QUEUE_EMPTY(&amp;loop-&gt;watcher_queue)) &#123;</span><br><span class="line">    q = QUEUE_HEAD(&amp;loop-&gt;watcher_queue);</span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    QUEUE_INIT(q);</span><br><span class="line"></span><br><span class="line">    w = QUEUE_DATA(q, <span class="hljs-keyword">uv__io_t</span>, watcher_queue);</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (w-&gt;events == <span class="hljs-number">0</span>)</span><br><span class="line">      op = EPOLL_CTL_ADD; <span class="hljs-comment">// 添加</span></span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">      op = EPOLL_CTL_MOD; <span class="hljs-comment">// 修改</span></span><br><span class="line"></span><br><span class="line">    epoll_ctl(loop-&gt;backend_fd, op, w-&gt;fd, &amp;e) <span class="hljs-comment">// epoll_ctl 底层的系统函数，将文件描述符关联起来</span></span><br><span class="line"></span><br><span class="line">    w-&gt;events = w-&gt;pevents;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sigmask = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">if</span> (loop-&gt;flags &amp; UV_LOOP_BLOCK_SIGPROF) &#123;</span><br><span class="line">    sigemptyset(&amp;sigset);</span><br><span class="line">    sigaddset(&amp;sigset, SIGPROF);</span><br><span class="line">    sigmask |= <span class="hljs-number">1</span> &lt;&lt; (SIGPROF - <span class="hljs-number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  base = loop-&gt;time;</span><br><span class="line">  real_timeout = timeout;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">    nfds = epoll_wait(loop-&gt;backend_fd,</span><br><span class="line">                        events,</span><br><span class="line">                        ARRAY_SIZE(events),</span><br><span class="line">                        timeout);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">if</span> (nfds == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 超时，没有新的事件准备好</span></span><br><span class="line">      assert(timeout != <span class="hljs-number">-1</span>); <span class="hljs-comment">// -1 表示不会超时，而nfds为0表示超时，存在矛盾所以抛出异常</span></span><br><span class="line">      <span class="hljs-keyword">if</span> (timeout == <span class="hljs-number">0</span>) <span class="hljs-comment">// 退出</span></span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="hljs-keyword">goto</span> update_timeout; <span class="hljs-comment">// 重新更新时间 准备下次循环 epoll_wait </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (nfds == <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">// 出错</span></span><br><span class="line">      <span class="hljs-keyword">if</span> (errno == ENOSYS) &#123;</span><br><span class="line">        <span class="hljs-comment">/* epoll_wait() or epoll_pwait() failed, try the other system call. */</span></span><br><span class="line">        assert(no_epoll_wait == <span class="hljs-number">0</span> || no_epoll_pwait == <span class="hljs-number">0</span>);</span><br><span class="line">        <span class="hljs-keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-keyword">if</span> (errno != EINTR)</span><br><span class="line">        <span class="hljs-built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">      <span class="hljs-keyword">if</span> (timeout == <span class="hljs-number">-1</span>)</span><br><span class="line">        <span class="hljs-keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-keyword">if</span> (timeout == <span class="hljs-number">0</span>)</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-keyword">goto</span> update_timeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    have_signals = <span class="hljs-number">0</span>;</span><br><span class="line">    nevents = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">    loop-&gt;watchers[loop-&gt;nwatchers] = (<span class="hljs-keyword">void</span>*) events;</span><br><span class="line">    loop-&gt;watchers[loop-&gt;nwatchers + <span class="hljs-number">1</span>] = (<span class="hljs-keyword">void</span>*) (<span class="hljs-keyword">uintptr_t</span>) nfds;</span><br><span class="line">    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">      pe = events + i;</span><br><span class="line">      fd = pe-&gt;data.fd;</span><br><span class="line">      w = loop-&gt;watchers[fd];</span><br><span class="line">      w-&gt;cb(loop, w, pe-&gt;events); <span class="hljs-comment">// 这个for循环很长，这里我简化了，其实就是准备好的IO就执行回调</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (timeout == <span class="hljs-number">0</span>)</span><br><span class="line">      <span class="hljs-keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (timeout == <span class="hljs-number">-1</span>)</span><br><span class="line">      <span class="hljs-keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">update_timeout:</span><br><span class="line">    assert(timeout &gt; <span class="hljs-number">0</span>);</span><br><span class="line"></span><br><span class="line">    real_timeout -= (loop-&gt;time - base);</span><br><span class="line">    <span class="hljs-keyword">if</span> (real_timeout &lt;= <span class="hljs-number">0</span>)</span><br><span class="line">      <span class="hljs-keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    timeout = real_timeout;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>uv__io_poll</code>里的timeout参数是根据<code>timers</code>里的最近一次定时时间计算出来的。方法内部使用了<code>epoll</code>，是IO多路复用的一个概念。一共有三种：<code>select</code>、<code>poll</code>和<code>epoll</code>。</p>
<blockquote>
<p>epoll是<a href="https://baike.baidu.com/item/Linux内核" target="_blank" rel="noopener">Linux内核</a>为处理大批量<a href="https://baike.baidu.com/item/文件描述符/9809582" target="_blank" rel="noopener">文件描述符</a>而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量<a href="https://baike.baidu.com/item/并发连接/3763280" target="_blank" rel="noopener">并发连接</a>中只有少量活跃的情况下的系统<a href="https://baike.baidu.com/item/CPU/120556" target="_blank" rel="noopener">CPU</a>利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。epoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。 ——百度百科</p>
</blockquote>
<p>我觉得libuv使用epoll主要是因为支持其自身的异步特点</p>
<ul>
<li>epoll监控的文件描述符远远大于select/poll</li>
<li>在大量并发的时候epoll性能远远高于select/poll，而少量异步select/poll相对好点。Node.js利用了libuv的高并发特点。</li>
</ul>
<p><br></p>
<figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">uv__run_closing_handles</span><span class="hljs-params">(<span class="hljs-keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">uv_handle_t</span>* p;</span><br><span class="line">  <span class="hljs-keyword">uv_handle_t</span>* q;</span><br><span class="line"></span><br><span class="line">  p = loop-&gt;closing_handles;</span><br><span class="line">  loop-&gt;closing_handles = <span class="hljs-literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">while</span> (p) &#123;</span><br><span class="line">    q = p-&gt;next_closing;</span><br><span class="line">    uv__finish_close(p);</span><br><span class="line">    p = q;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个个触发<code>close</code>回调</p>
<p><br></p>
<p>上述就是libuv各个阶段的大体流程，<code>poll</code>最为复杂，还有很多东西可以留着细品。</p>
<p><br></p>
<p><br></p>
<h2 id="Node-js-setTimeout"><a href="#Node-js-setTimeout" class="headerlink" title="Node.js setTimeout"></a>Node.js setTimeout</h2><p>上文中提到<strong>那么这里的<code>handle-&gt;timer_cb</code>是我们平时JavaScript里的setTimeout回调吗？回答：不是的</strong></p>
<p>看看Node.js里面如何具体实现这个<code>setTimemout</code>方法的</p>
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setTimeout</span>(<span class="hljs-params">callback, after, arg1, arg2, arg3</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> args = [arg1, arg2, arg3]; <span class="hljs-comment">// 简化了代码</span></span><br><span class="line">  <span class="hljs-keyword">const</span> timeout = <span class="hljs-keyword">new</span> Timeout(callback, after, args, <span class="hljs-literal">false</span>);</span><br><span class="line">  active(timeout);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> timeout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Timeout</span>(<span class="hljs-params">callback, after, args, isRepeat</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 省略了部分代码</span></span><br><span class="line">  after *= <span class="hljs-number">1</span>; </span><br><span class="line">  <span class="hljs-keyword">if</span> (!(after &gt;= <span class="hljs-number">1</span> &amp;&amp; after &lt;= TIMEOUT_MAX)) &#123;</span><br><span class="line">    after = <span class="hljs-number">1</span>; <span class="hljs-comment">// 定时验证不过 就为1 </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">this</span>._idleTimeout = after;</span><br><span class="line">  <span class="hljs-keyword">this</span>._onTimeout = callback;</span><br><span class="line">  <span class="hljs-keyword">this</span>._timerArgs = args;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">active</span>(<span class="hljs-params">item</span>) </span>&#123;</span><br><span class="line">  insert(item, <span class="hljs-literal">true</span>, getLibuvNow());  <span class="hljs-comment">// getLibuvNow 获取 loop-&gt;time时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insert</span>(<span class="hljs-params">item, refed, start</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">let</span> msecs = item._idleTimeout;</span><br><span class="line">  <span class="hljs-keyword">if</span> (msecs &lt; <span class="hljs-number">0</span> || msecs === <span class="hljs-literal">undefined</span>)</span><br><span class="line">    <span class="hljs-keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// Truncate so that accuracy of sub-millisecond timers is not assumed.</span></span><br><span class="line">  msecs = <span class="hljs-built_in">Math</span>.trunc(msecs);</span><br><span class="line"></span><br><span class="line">  item._idleStart = start;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// Use an existing list if there is one, otherwise we need to make a new one.</span></span><br><span class="line">  <span class="hljs-comment">// timerListMap 是一个键值对，key 是定时时间，value 是一个TimersList</span></span><br><span class="line">  <span class="hljs-keyword">var</span> list = timerListMap[msecs];</span><br><span class="line">  <span class="hljs-keyword">if</span> (list === <span class="hljs-literal">undefined</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> expiry = start + msecs; <span class="hljs-comment">// 过期时间</span></span><br><span class="line">    timerListMap[msecs] = list = <span class="hljs-keyword">new</span> TimersList(expiry, msecs); <span class="hljs-comment">// 双向链表</span></span><br><span class="line">    timerListQueue.insert(list); <span class="hljs-comment">// timerListQueue 用数组实现的最小堆</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (nextExpiry &gt; expiry) &#123;</span><br><span class="line">      scheduleTimer(msecs); <span class="hljs-comment">// 如果此次定时任务的有效时间小的话，调用 V8 scheduleTimer</span></span><br><span class="line">      nextExpiry = expiry;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">// ... 这边简略代码</span></span><br><span class="line">  L.append(list, item); <span class="hljs-comment">// 将setTimeout创建的Timeout对象添加到list尾部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述代码，我们也可以看出JavaScript层面也有一个维护timers的最小堆，并没有吧具体的某个setTimeout注册到V8里面，只是将定时时间告诉了V8<code>scheduleTimer(msecs);</code>，下面是V8相关代码。</p>
<figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// timers.cc</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ScheduleTimer</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">auto</span> env = Environment::GetCurrent(args);</span><br><span class="line">  env-&gt;ScheduleTimer(args[<span class="hljs-number">0</span>]-&gt;IntegerValue(env-&gt;context()).FromJust());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// env.cc</span></span><br><span class="line"><span class="hljs-keyword">void</span> Environment::ScheduleTimer(<span class="hljs-keyword">int64_t</span> duration_ms) &#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (started_cleanup_) <span class="hljs-keyword">return</span>;</span><br><span class="line">  uv_timer_start(timer_handle(), RunTimers, duration_ms, <span class="hljs-number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">void</span> Environment::RunTimers(<span class="hljs-keyword">uv_timer_t</span>* handle) &#123;</span><br><span class="line">  Environment* env = Environment::from_timer_handle(handle);</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-comment">// timers_callback_function 从何而来呢？</span></span><br><span class="line">  Local&lt;Function&gt; cb = env-&gt;timers_callback_function();</span><br><span class="line">  <span class="hljs-keyword">do</span> &#123;</span><br><span class="line">    ret = cb-&gt;Call(env-&gt;context(), process, <span class="hljs-number">1</span>, &amp;arg);</span><br><span class="line">  &#125; <span class="hljs-keyword">while</span> (ret.IsEmpty() &amp;&amp; env-&gt;can_call_into_js());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// uv/timer.c</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uv_timer_start</span><span class="hljs-params">(<span class="hljs-keyword">uv_timer_t</span>* handle,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                   uv_timer_cb cb,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                   <span class="hljs-keyword">uint64_t</span> timeout,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                   <span class="hljs-keyword">uint64_t</span> repeat)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 给uv_timer_t对象初始化相关属性</span></span><br><span class="line">  <span class="hljs-comment">// 并没有JavaScript层面的回调方法，具体的回调也只是C++的RunTimers</span></span><br><span class="line">  handle-&gt;timer_cb = cb;</span><br><span class="line">  handle-&gt;timeout = clamped_timeout;</span><br><span class="line">  handle-&gt;repeat = repeat;</span><br><span class="line">  handle-&gt;start_id = handle-&gt;loop-&gt;timer_counter++;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 将uv_timer_t添加到timer_heap上</span></span><br><span class="line">  heap_insert(timer_heap(handle-&gt;loop),</span><br><span class="line">              (struct heap_node*) &amp;handle-&gt;heap_node,</span><br><span class="line">              timer_less_than);</span><br><span class="line">  uv__handle_start(handle);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>V8部分注册在timers阶段的是一个C++的回调方法</strong>，其内部是执行<code>timers_callback_function</code>方法，它从何来来？</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// timers.cc</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetupTimers</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">  CHECK(args[<span class="hljs-number">0</span>]-&gt;IsFunction());</span><br><span class="line">  CHECK(args[<span class="hljs-number">1</span>]-&gt;IsFunction());</span><br><span class="line">  <span class="hljs-keyword">auto</span> env = Environment::GetCurrent(args);</span><br><span class="line"></span><br><span class="line">  env-&gt;set_immediate_callback_function(args[<span class="hljs-number">0</span>].As&lt;Function&gt;()); <span class="hljs-comment">// 注册了immediate回调</span></span><br><span class="line">  env-&gt;set_timers_callback_function(args[<span class="hljs-number">1</span>].As&lt;Function&gt;()); <span class="hljs-comment">// 注册了timers回调</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// node.js</span></span><br><span class="line"><span class="hljs-keyword">const</span> &#123;</span><br><span class="line">  setupTaskQueue,</span><br><span class="line">  queueMicrotask</span><br><span class="line">&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'internal/process/task_queues'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> &#123; nextTick, runNextTicks &#125; = setupTaskQueue();</span><br><span class="line">process.nextTick = nextTick;</span><br><span class="line">process._tickCallback = runNextTicks;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> &#123; getTimerCallbacks &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'internal/timers'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> &#123; setupTimers &#125; = internalBinding(<span class="hljs-string">'timers'</span>); <span class="hljs-comment">// c++ SetupTimers 方法传到了JavaScript层</span></span><br><span class="line"><span class="hljs-keyword">const</span> &#123; processImmediate, processTimers &#125; = getTimerCallbacks(runNextTicks);</span><br><span class="line">setupTimers(processImmediate, processTimers);</span><br></pre></td></tr></table></figure>
<p>我们通过上述代码看到在<code>node.js</code>里面会将<code>processImmediate</code>和<code>processTimers</code>这两个JavaScript方法注册到对应的C++回调里，之后执行<code>timers_callback_function</code>其实就是执行<code>processTimers</code>方法。</p>
<p>另外，需要注意<code>微任务</code>相关的代码会被带到<code>getTimerCallbacks</code>。</p>
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTimerCallbacks</span>(<span class="hljs-params">runNextTicks</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processImmediate</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 之后文章在做介绍</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processTimers</span>(<span class="hljs-params">now</span>) </span>&#123;</span><br><span class="line">    nextExpiry = <span class="hljs-literal">Infinity</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">let</span> list;</span><br><span class="line">    <span class="hljs-keyword">let</span> ranAtLeastOneList = <span class="hljs-literal">false</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (list = timerListQueue.peek()) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (list.expiry &gt; now) &#123; <span class="hljs-comment">// 当前列表的过期时间大于now(libuv loop-&gt;time), 还没有到过期或到触发时间</span></span><br><span class="line">        nextExpiry = list.expiry; <span class="hljs-comment">// nextExpiry 设置为 当前列表的过期时间</span></span><br><span class="line">        <span class="hljs-keyword">return</span> refCount &gt; <span class="hljs-number">0</span> ? nextExpiry : -nextExpiry;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-keyword">if</span> (ranAtLeastOneList)</span><br><span class="line">        runNextTicks(); <span class="hljs-comment">// 微任务会被触发</span></span><br><span class="line">      <span class="hljs-keyword">else</span></span><br><span class="line">        ranAtLeastOneList = <span class="hljs-literal">true</span>;</span><br><span class="line">      listOnTimeout(list, now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">listOnTimeout</span>(<span class="hljs-params">list, now</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> msecs = list.msecs;</span><br><span class="line"></span><br><span class="line">    debug(<span class="hljs-string">'timeout callback %d'</span>, msecs);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> diff, timer;</span><br><span class="line">    <span class="hljs-keyword">let</span> ranAtLeastOneTimer = <span class="hljs-literal">false</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (timer = L.peek(list)) &#123; <span class="hljs-comment">// 如果不是一个空的list，持续执行</span></span><br><span class="line">      <span class="hljs-comment">// _idleStart 是插入libuv (loop-&gt;time)的时间</span></span><br><span class="line">      <span class="hljs-comment">// now 是当前libuv 执行此次callback的时间</span></span><br><span class="line">      diff = now - timer._idleStart; </span><br><span class="line"></span><br><span class="line">      <span class="hljs-comment">// Check if this loop iteration is too early for the next timer.</span></span><br><span class="line">      <span class="hljs-comment">// This happens if there are more timers scheduled for later in the list.</span></span><br><span class="line">      <span class="hljs-keyword">if</span> (diff &lt; msecs) &#123;</span><br><span class="line">        list.expiry = <span class="hljs-built_in">Math</span>.max(timer._idleStart + msecs, now + <span class="hljs-number">1</span>);</span><br><span class="line">        list.id = timerListId++;</span><br><span class="line">        timerListQueue.percolateDown(<span class="hljs-number">1</span>);</span><br><span class="line">        debug(<span class="hljs-string">'%d list wait because diff is %d'</span>, msecs, diff);</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-keyword">if</span> (ranAtLeastOneTimer)</span><br><span class="line">        runNextTicks(); <span class="hljs-comment">// 微任务会被触发</span></span><br><span class="line">      <span class="hljs-keyword">else</span></span><br><span class="line">        ranAtLeastOneTimer = <span class="hljs-literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-comment">// The actual logic for when a timeout happens.</span></span><br><span class="line">      L.remove(timer);</span><br><span class="line"></span><br><span class="line">      <span class="hljs-keyword">const</span> asyncId = timer[async_id_symbol];</span><br><span class="line">      <span class="hljs-keyword">if</span> (!timer._onTimeout) &#123;</span><br><span class="line">        <span class="hljs-keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">const</span> args = timer._timerArgs;</span><br><span class="line">        <span class="hljs-keyword">if</span> (args === <span class="hljs-literal">undefined</span>)</span><br><span class="line">          timer._onTimeout(); <span class="hljs-comment">// _onTimeout setTimeout 回调</span></span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">          timer._onTimeout(...args);</span><br><span class="line">      &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (list === timerListMap[msecs]) &#123;</span><br><span class="line">      <span class="hljs-keyword">delete</span> timerListMap[msecs];</span><br><span class="line">      timerListQueue.shift();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">    processImmediate,</span><br><span class="line">    processTimers</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码很长，但是很容易理解，就是根据<code>libuv</code>的时间，将到期的定时任务一一执行了，格外需要注意的是微任务的执行<code>runNextTicks</code>，<strong>每次setTimeout的callback之后都会将<code>微任务</code>清空，而不是网上很多文章说的timer阶段之后将微任务清空，这个改动在Node.js 11版本</strong></p>
<blockquote>
<p>Timers<br>Interval timers will be rescheduled even if previous interval threw an error. #20002<br><strong>nextTick queue will be run after each immediate and timer. <a href="https://github.com/nodejs/node/pull/22842" target="_blank" rel="noopener">#22842</a></strong></p>
</blockquote>
<p>具体的原因是希望和浏览器里的行为更为一直，下面的代码在11之前和之后的执行结果略有不同。</p>
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'time1'</span>);</span><br><span class="line">  <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise1'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'time2'</span>);</span><br><span class="line">  <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise2'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 11之后</span></span><br><span class="line"><span class="hljs-comment">time1</span></span><br><span class="line"><span class="hljs-comment">promise1</span></span><br><span class="line"><span class="hljs-comment">time2</span></span><br><span class="line"><span class="hljs-comment">promise2</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 11之前</span></span><br><span class="line"><span class="hljs-comment">time1</span></span><br><span class="line"><span class="hljs-comment">time2</span></span><br><span class="line"><span class="hljs-comment">promise1</span></span><br><span class="line"><span class="hljs-comment">promise2</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，libuv和Node.js EventLoop关于<code>各个阶段</code>和<code>setTimeout</code>的实现已经做了简单介绍。具体的还是需要看各自版本的代码而定，不能轻易去“相信”网上的介绍，比如最后一个例子就很容易在不同版本出现不同的执行结果。之后，有时间介绍 <code>nextTick</code>的回调实现，这个比较复杂。</p>

    
    </div>
    
    <div class="columns is-variable is-1 is-multiline is-mobile">
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Node-js/">#Node.js</a></span>
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/JavaScript/">#JavaScript</a></span>
    
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop  article-nav-prev">
            
            <a href="/2020/04/03/monitor-hub/">Node.js 监控中心架构迭代</a>
            
        </span>
        <span class="column is-12-mobile is-half-desktop  article-nav-next">
            
            <a href="/2020/02/21/node-perf-heapdump-flame-graph/">收集Node.js应用的内存堆栈快照和CPU火焰图</a>
            
        </span>
    </div>
    
</article>



<div class="comments">
    <div class="adv">
  <ul>
    <li class="img"><img src="/images/give-a-reward.png" alt="reward"></li>
    <li>
      欢迎加入<a href="https://oriente.com/" target="_blank">Oriente</a>前端组，<a href="https://www.lagou.com/jobs/4927018.html?source=pl&i=pl-3" target="_blank">岗位信息</a>
    </li>
    <li>
      同时也欢迎光顾我的小店<a href="http://aimianwu.com" target="_blank">爱眠物</a>
    </li>
  </ul>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- 尾部广告 -->
  <ins class="adsbygoogle" style="display: block" data-ad-client="ca-pub-6006630417531788" data-ad-slot="2988625841" data-ad-format="auto" data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>

    <h3 class="title is-4">Comments</h3>
    
<script>
    var disqus_config = function () {
        this.page.url = 'https://mlib.wang/2020/03/01/v8-libuv-timer-event-loop/';
        this.page.identifier = '2020/03/01/v8-libuv-timer-event-loop/';
        
        this.language = 'en';
        
    };
    (function() {
        var d = document, s = d.createElement('script');  
        s.src = '//' + 'mblof' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>

<div id="disqus_thread">
    
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</div>

    </div>
</section> <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2020 Miser&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            
        </div>
    </div>
</footer> <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("en-AU");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {matchFontHeight: false},
        SVG: {matchFontHeight: false},
        CommonHTML: {matchFontHeight: false}
    });
</script>

    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    

    


<script src="/js/script.js"></script> 
  </body>
</html>
